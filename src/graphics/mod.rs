// use winit::event_loop;


// pub fn draw_default_buildings() {
//     let event_loop = event_loop::EventLoopBuilder::new().build()
//         .unwrap();

//     let (window, display) = glium::backend::glutin::SimpleWindowBuilder::new()
//         .with_title("Glium tutorial #3")
//         .build(&event_loop);

//     #[derive(Copy, Clone)]
//     struct Vertex {
//         position: [f64; 2],
//     }
//     implement_vertex!(Vertex, position);

//     let shape = vec![
//         Vertex { position: [-0.1, -0.1] },
//         Vertex { position: [ 0.0,  0.5] },
//         Vertex { position: [ 0.5, -0.25] }
//     ];
//     let vertex_buffer = glium::VertexBuffer::new(&display, &shape).unwrap();
//     let indices = glium::index::NoIndices(glium::index::PrimitiveType::TrianglesList);

//     let vertex_shader_src = r#"
//         #version 140

//         in vec2 position;
//         uniform float x_off;

//         void main() {
//             vec2 pos = position;
//             pos.x += x_off;
//             gl_Position = vec4(pos, 0.0, 1.0);
//         }
//     "#;
//     let fragment_shader_src = r#"
//         #version 140

//         out vec4 color;

//         void main() {
//             color = vec4(1.0, 0.0, 0.0, 1.0);
//         }
//     "#;
//     let program = glium::Program::from_source(&display, vertex_shader_src, fragment_shader_src, None).unwrap();

//     let mut t: f32 = 0.0;

//     event_loop.run(move |ev, window_target| {
//         match ev {
//             winit::event::Event::WindowEvent { event, .. } => match event {
//                 winit::event::WindowEvent::CloseRequested => {
//                     window_target.exit();
//                 },
//                 // We now need to render everyting in response to a RedrawRequested event due to the animation
//                 winit::event::WindowEvent::RedrawRequested => {
//                     // first we update `t`
//                     t += 0.02;
//                     let x_off = t.sin() * 0.5;

//                     let mut target = display.draw();
//                     target.clear_color(0.0, 0.0, 1.0, 1.0);
//                     let uniforms = uniform! { x_off: x_off };
//                     target.draw(&vertex_buffer, &indices, &program, &uniforms,
//                                 &Default::default()).unwrap();
//                     target.finish().unwrap();
//                 },
//                 // Because glium doesn't know about windows we need to resize the display
//                 // when the window's size has changed.
//                 winit::event::WindowEvent::Resized(window_size) => {
//                     display.resize(window_size.into());
//                 },
//                 _ => (),
//             },
//             // By requesting a redraw in response to a RedrawEventsCleared event we get continuous rendering.
//             // For applications that only change due to user input you could remove this handler.
//             winit::event::Event::AboutToWait => {
//                 window.request_redraw();
//             },
//             _ => (),
//         }
//     })
//     .unwrap();
// }
